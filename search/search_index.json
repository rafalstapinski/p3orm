{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"p3orm Utilitarian Python ORM for Postgres, backed by asyncpg , Pydantic and PyPika Philosophy 90% of the time we talk to a database is with a CRUD operation. porm provides convenience helpers for fetching (one, first, many), inserting (one, many), updating (one), and deleting (one, many). The remaining 10% is a bit more complicated. porm doesn't attempt to hide SQL queries behind any magic, instead it empowers you to write direct, explicit, and legible SQL queries with [PyPika](https://github.com/kayak/pypika). Object created or fetched by p3orm are **dead**, they're just Pydantic models. If you want to manipulate the database, you do so explicitly. Features Comprehensive type annotations (full intellisense support) Type validation Full support for PyPika queries Installation Install with poetry poetry add p3orm or with pip pip install p3orm Basic Usage from datetime import datetime from p3orm.core import Porm from p3orm.table import Table , PormField class Thing ( Table ): id = PormField ( int , \"id\" , pk = True , autogen = True ) name = PormField ( str , \"name\" ) created_at = PormField ( datetime , \"created_at\" , autogen = True ) await Porm . connect ( user =... , password =... , database =... , host =... , port =... ) thing = Thing ( name = \"Name\" ) inserted = await Thing . insert_one ( thing ) fetched = await Thing . fetch_first ( Thing . id == 1 ) fetched . name = \"Changed\" updated = await Thing . update_one ( fetched ) deleted = await Thing . delete ( Thing . id == updated . id )","title":"About"},{"location":"#p3orm","text":"Utilitarian Python ORM for Postgres, backed by asyncpg , Pydantic and PyPika","title":"p3orm"},{"location":"getting_started/","text":"Getting started Connecting to the database from p3orm.core import Porm await Porm . connect ( \"postgresql://user:pass@host:port\" ) # or await Porm . connect ( user =... , password =... , database =... , host =... , port =... ) Porm . connection . is_closed () # False Disconnecting await Porm . disconnect () Porm . connection . is_closed () # True Porm maintains a singleton to be loaded from p3orm.core . Defining models from datetime import datetime from typing import Optional from p3orm.table import Table , PormField class Thing ( Table ): __tablename__ = \"thing\" id = PormField ( int , \"id\" , autogen = True ) name = PormField ( Optional [ str ], \"name\" ) created_at = PormField ( datetime , \"created_at\" , autogen = True ) PormField parameters _type : Specifies the type of the column, will be used to convert between Python and Postgres. This also generates the type annotation for an instance of your model. For a list of supported types, see the asyncpg docs . name : Specifies the name of the column. This (currently) has to match the name of the field on the class as well. pk : Specifies whether this is the primary key. This is used for the update_one convenience function. autogen : Specifies whether Postgres will automatically generate/update the value of this field, e.g. SERIAL for ids or DEFAULT CURRENT_TIMESTAMP for created_at or updated_at type fields. Creating inserted_result = await Thing . insert_one ( Thing ( name = \"thing 1\" )) to_insert = [ Thing ( name = \"thing 2\" ), Thing ( name = \"thing 3\" )] inserted_results = await Thing . insert_many ( to_insert ) Notice we didn't specify the id or created_at fields. Those are autogenerated by Postgres, so we let the database do the work. We also didn't explicitly specify whether the fields are nullable or not. Again, we offload all validation to the database as the source of truth, and only specify the Optional type for local type checking and intellisense. Retrieving everything = await Thing . fetch_all () filtered = await Thing . fetch_all ( Thing . id > 2 ) first = await Thing . fetch_first ( Thing . id > 2 ) one = await Thing . fetch_one ( Thing . id == 1 ) Updating thing = await Thing . fetch_one ( Thing . id == 2 ) thing . name = \"Changed\" thing = await Thing . update_one ( thing ) Deleting deleted_things = await Thing . delete ( Thing . id > 10 ) Table.delete always returns a list of the deleted records.","title":"Getting Started"},{"location":"getting_started/#getting-started","text":"","title":"Getting started"},{"location":"getting_started/#connecting-to-the-database","text":"from p3orm.core import Porm await Porm . connect ( \"postgresql://user:pass@host:port\" ) # or await Porm . connect ( user =... , password =... , database =... , host =... , port =... ) Porm . connection . is_closed () # False","title":"Connecting to the database"},{"location":"getting_started/#disconnecting","text":"await Porm . disconnect () Porm . connection . is_closed () # True Porm maintains a singleton to be loaded from p3orm.core .","title":"Disconnecting"},{"location":"getting_started/#defining-models","text":"from datetime import datetime from typing import Optional from p3orm.table import Table , PormField class Thing ( Table ): __tablename__ = \"thing\" id = PormField ( int , \"id\" , autogen = True ) name = PormField ( Optional [ str ], \"name\" ) created_at = PormField ( datetime , \"created_at\" , autogen = True )","title":"Defining models"},{"location":"getting_started/#pormfield-parameters","text":"_type : Specifies the type of the column, will be used to convert between Python and Postgres. This also generates the type annotation for an instance of your model. For a list of supported types, see the asyncpg docs . name : Specifies the name of the column. This (currently) has to match the name of the field on the class as well. pk : Specifies whether this is the primary key. This is used for the update_one convenience function. autogen : Specifies whether Postgres will automatically generate/update the value of this field, e.g. SERIAL for ids or DEFAULT CURRENT_TIMESTAMP for created_at or updated_at type fields.","title":"PormField parameters"},{"location":"getting_started/#creating","text":"inserted_result = await Thing . insert_one ( Thing ( name = \"thing 1\" )) to_insert = [ Thing ( name = \"thing 2\" ), Thing ( name = \"thing 3\" )] inserted_results = await Thing . insert_many ( to_insert ) Notice we didn't specify the id or created_at fields. Those are autogenerated by Postgres, so we let the database do the work. We also didn't explicitly specify whether the fields are nullable or not. Again, we offload all validation to the database as the source of truth, and only specify the Optional type for local type checking and intellisense.","title":"Creating"},{"location":"getting_started/#retrieving","text":"everything = await Thing . fetch_all () filtered = await Thing . fetch_all ( Thing . id > 2 ) first = await Thing . fetch_first ( Thing . id > 2 ) one = await Thing . fetch_one ( Thing . id == 1 )","title":"Retrieving"},{"location":"getting_started/#updating","text":"thing = await Thing . fetch_one ( Thing . id == 2 ) thing . name = \"Changed\" thing = await Thing . update_one ( thing )","title":"Updating"},{"location":"getting_started/#deleting","text":"deleted_things = await Thing . delete ( Thing . id > 10 ) Table.delete always returns a list of the deleted records.","title":"Deleting"},{"location":"tutorial/complex_queries/","text":"Complex queries docs are wip","title":"Complex Queries"},{"location":"tutorial/complex_queries/#complex-queries","text":"docs are wip","title":"Complex queries"},{"location":"tutorial/connection_pool/","text":"Connection pool docs are wip","title":"Connection Pool"},{"location":"tutorial/connection_pool/#connection-pool","text":"docs are wip","title":"Connection pool"},{"location":"tutorial/multiple_databases/","text":"Multiple Databases docs are wip","title":"Multiple Databases"},{"location":"tutorial/multiple_databases/#multiple-databases","text":"docs are wip","title":"Multiple Databases"},{"location":"tutorial/relationships/","text":"Relationships docs are wip","title":"Relationships"},{"location":"tutorial/relationships/#relationships","text":"docs are wip","title":"Relationships"}]}