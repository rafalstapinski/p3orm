{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"p3orm Utilitarian Python ORM for Postgres, backed by asyncpg , Pydantic , and PyPika Documentation : https://rafalstapinski.github.io/p3orm Source Code : https://github.com/rafalstapinski/p3orm Philosophy 90% of the time we talk to a database is with a CRUD operation. p3orm provides convenience helpers for fetching (one, first, many), inserting (one, many), updating (one), and deleting (one, many). The remaining 10% is a bit more complicated. p3orm doesn't attempt to hide SQL queries or database interactions behind any magic. Instead, it empowers you to write direct and legible SQL queries with PyPika and execute them explicitly against the database. Objects created or fetched by p3orm are dead, they're just Pydantic models. If you want to interact with the database, you do so explicitly. Features Comprehensive type annotations (full intellisense support) Type validation Full support for PyPika queries Support for all asyncpg types Installation Install with poetry poetry add p3orm or with pip pip install p3orm Basic Usage from datetime import datetime from p3orm import Table , Column , Porm class Thing ( Table ): id = Column ( int , \"id\" , pk = True , autogen = True ) name = Column ( str , \"name\" ) created_at = Column ( datetime , \"created_at\" , autogen = True ) await Porm . connect ( user =... , password =... , database =... , host =... , port =... ) thing = Thing ( name = \"Name\" ) inserted = await Thing . insert_one ( thing ) fetched = await Thing . fetch_first ( Thing . id == 1 ) fetched . name = \"Changed\" updated = await Thing . update_one ( fetched ) deleted = await Thing . delete_where ( Thing . id == updated . id )","title":"About"},{"location":"#p3orm","text":"Utilitarian Python ORM for Postgres, backed by asyncpg , Pydantic , and PyPika Documentation : https://rafalstapinski.github.io/p3orm Source Code : https://github.com/rafalstapinski/p3orm","title":"p3orm"},{"location":"#objects-created-or-fetched-by-p3orm-are-dead-theyre-just-pydantic-models-if-you-want-to-interact-with-the-database-you-do-so-explicitly","text":"","title":"Objects created or fetched by p3orm are dead, they're just Pydantic models. If you want to interact with the database, you do so explicitly."},{"location":"contributing/","text":"Contributing to p3orm p3orm is still in its infancy. If you find a bug, open an issue with a detailed description and steps to reproduce. If you're looking for a feature, open an issue with a detailed description and use case. Feel free open a pull request if you want to contribure directly!","title":"Contributing"},{"location":"contributing/#contributing-to-p3orm","text":"p3orm is still in its infancy. If you find a bug, open an issue with a detailed description and steps to reproduce. If you're looking for a feature, open an issue with a detailed description and use case. Feel free open a pull request if you want to contribure directly!","title":"Contributing to p3orm"},{"location":"getting_started/","text":"Getting started Connecting to the database from p3orm import Porm await Porm . connect ( \"postgresql://user:pass@host:port\" ) # or await Porm . connect ( user =... , password =... , database =... , host =... , port =... ) Porm . connection . is_closed () # False Disconnecting await Porm . disconnect () Porm . connection . is_closed () # True Porm maintains the singleton Porm that can be used to access a database. Defining models from datetime import datetime from typing import Optional from p3orm import Table , Column class Thing ( Table ): __tablename__ = \"thing\" id = Column ( int , \"id\" , autogen = True ) name = Column ( Optional [ str ], \"name\" ) created_at = Column ( datetime , \"created_at\" , autogen = True ) _PormField parameters _type : Specifies the type of the column, will be used to convert between Python and Postgres. This also generates the type annotation for an instance of your model. For a list of supported types, see the asyncpg docs . name : Specifies the name of the column. This (currently) has to match the name of the field on the class as well. pk : Specifies whether this is the primary key. This is used for the update_one convenience function. autogen : Specifies whether Postgres will automatically generate/update the value of this field, e.g. SERIAL for ids or DEFAULT CURRENT_TIMESTAMP for created_at or updated_at type fields. Creating inserted_result = await Thing . insert_one ( Thing ( name = \"thing 1\" )) to_insert = [ Thing ( name = \"thing 2\" ), Thing ( name = \"thing 3\" )] inserted_results = await Thing . insert_many ( to_insert ) Notice we didn't specify the id or created_at fields. Those are autogenerated by Postgres, so we let the database do the work. We also didn't explicitly specify whether the fields are nullable or not. Again, we offload all validation to the database as the source of truth, and only specify the Optional type for local type checking and intellisense. Retrieving everything = await Thing . fetch_all () filtered = await Thing . fetch_all ( Thing . id > 2 ) first = await Thing . fetch_first ( Thing . id > 2 ) one = await Thing . fetch_one ( Thing . id == 1 ) Updating thing = await Thing . fetch_one ( Thing . id == 2 ) thing . name = \"Changed\" thing = await Thing . update_one ( thing ) Deleting deleted_things = await Thing . delete ( Thing . id > 10 ) Table.delete always returns a list of the deleted records.","title":"Getting Started"},{"location":"getting_started/#getting-started","text":"","title":"Getting started"},{"location":"getting_started/#connecting-to-the-database","text":"from p3orm import Porm await Porm . connect ( \"postgresql://user:pass@host:port\" ) # or await Porm . connect ( user =... , password =... , database =... , host =... , port =... ) Porm . connection . is_closed () # False","title":"Connecting to the database"},{"location":"getting_started/#disconnecting","text":"await Porm . disconnect () Porm . connection . is_closed () # True Porm maintains the singleton Porm that can be used to access a database.","title":"Disconnecting"},{"location":"getting_started/#defining-models","text":"from datetime import datetime from typing import Optional from p3orm import Table , Column class Thing ( Table ): __tablename__ = \"thing\" id = Column ( int , \"id\" , autogen = True ) name = Column ( Optional [ str ], \"name\" ) created_at = Column ( datetime , \"created_at\" , autogen = True )","title":"Defining models"},{"location":"getting_started/#_pormfield-parameters","text":"_type : Specifies the type of the column, will be used to convert between Python and Postgres. This also generates the type annotation for an instance of your model. For a list of supported types, see the asyncpg docs . name : Specifies the name of the column. This (currently) has to match the name of the field on the class as well. pk : Specifies whether this is the primary key. This is used for the update_one convenience function. autogen : Specifies whether Postgres will automatically generate/update the value of this field, e.g. SERIAL for ids or DEFAULT CURRENT_TIMESTAMP for created_at or updated_at type fields.","title":"_PormField parameters"},{"location":"getting_started/#creating","text":"inserted_result = await Thing . insert_one ( Thing ( name = \"thing 1\" )) to_insert = [ Thing ( name = \"thing 2\" ), Thing ( name = \"thing 3\" )] inserted_results = await Thing . insert_many ( to_insert ) Notice we didn't specify the id or created_at fields. Those are autogenerated by Postgres, so we let the database do the work. We also didn't explicitly specify whether the fields are nullable or not. Again, we offload all validation to the database as the source of truth, and only specify the Optional type for local type checking and intellisense.","title":"Creating"},{"location":"getting_started/#retrieving","text":"everything = await Thing . fetch_all () filtered = await Thing . fetch_all ( Thing . id > 2 ) first = await Thing . fetch_first ( Thing . id > 2 ) one = await Thing . fetch_one ( Thing . id == 1 )","title":"Retrieving"},{"location":"getting_started/#updating","text":"thing = await Thing . fetch_one ( Thing . id == 2 ) thing . name = \"Changed\" thing = await Thing . update_one ( thing )","title":"Updating"},{"location":"getting_started/#deleting","text":"deleted_things = await Thing . delete ( Thing . id > 10 ) Table.delete always returns a list of the deleted records.","title":"Deleting"},{"location":"tutorial/complex_queries/","text":"Complex queries p3orm has full support for executing PyPika queries. PyPika queries are constructed by building blocks that are analogous to the underlying SQL, the learning curve is minimal if you already know SQL. Available PyPika shortcuts select - Equivalent to PyPika's QueryBuilder().from_(tablename).select(field) . This defaults field to return everything * but you can pass in a specific _PormField for executing subqueries. update - Equivalent to PyPika's QueryBuilder().update(tablename) . You can then chain this with your own .where() and .set() statements. delete - Equivalent to PyPika's QueryBuilder().delete().from(tablename) . You can then chain this with your own .where() statement. from_ -> Calls underlying QueryBuilder().from_(tablename) , useful if you need to execute broader queries. Selecting with PyPika queries subquery = OtherThing . select ( \"thing_id\" ) . where ( OtherThing . id == 1 ) query = Thing . select () . where ( Thing . id . isin ( subquery )) things = await Thing . execute_many ( query ) Updating with PyPika queries from p3orm import with_returning query = Thing . update () . where ( Thing . name == \"name\" ) . set ( Thing . name , \"another name\" ) updated_things = await Thing . execute_many ( with_returning ( query )) Deleting with PyPika queries from p3orm.utils import with_returning subquery = OtherThing . from_ () . select ( \"thing_id\" ) . where ( OtherThing . id == 1 ) query = Thing . delete () . where ( Thing . id . isin ( subquery )) deleted_things = await Thing . execute_many ( with_returning ( query ))","title":"Complex Queries"},{"location":"tutorial/complex_queries/#complex-queries","text":"p3orm has full support for executing PyPika queries. PyPika queries are constructed by building blocks that are analogous to the underlying SQL, the learning curve is minimal if you already know SQL.","title":"Complex queries"},{"location":"tutorial/complex_queries/#available-pypika-shortcuts","text":"select - Equivalent to PyPika's QueryBuilder().from_(tablename).select(field) . This defaults field to return everything * but you can pass in a specific _PormField for executing subqueries. update - Equivalent to PyPika's QueryBuilder().update(tablename) . You can then chain this with your own .where() and .set() statements. delete - Equivalent to PyPika's QueryBuilder().delete().from(tablename) . You can then chain this with your own .where() statement. from_ -> Calls underlying QueryBuilder().from_(tablename) , useful if you need to execute broader queries.","title":"Available PyPika shortcuts"},{"location":"tutorial/complex_queries/#selecting-with-pypika-queries","text":"subquery = OtherThing . select ( \"thing_id\" ) . where ( OtherThing . id == 1 ) query = Thing . select () . where ( Thing . id . isin ( subquery )) things = await Thing . execute_many ( query )","title":"Selecting with PyPika queries"},{"location":"tutorial/complex_queries/#updating-with-pypika-queries","text":"from p3orm import with_returning query = Thing . update () . where ( Thing . name == \"name\" ) . set ( Thing . name , \"another name\" ) updated_things = await Thing . execute_many ( with_returning ( query ))","title":"Updating with PyPika queries"},{"location":"tutorial/complex_queries/#deleting-with-pypika-queries","text":"from p3orm.utils import with_returning subquery = OtherThing . from_ () . select ( \"thing_id\" ) . where ( OtherThing . id == 1 ) query = Thing . delete () . where ( Thing . id . isin ( subquery )) deleted_things = await Thing . execute_many ( with_returning ( query ))","title":"Deleting with PyPika queries"},{"location":"tutorial/connecting/","text":"Connecting to the database p3orm allows you to connect either with a direct connection or with a connection pool. You can only connect with one of these at a time on a single instance. If you attempt to establish a new connection or pool while one already exists, p3orm will raise a p3orm.exceptions.AlreadyConnected exception. Regular connections With p3orm you can open a single connection to the database. This is useful for simpler short lived applications like a script. You can open a connection by using the _Porm.connect method. from p3orm import Porm await Porm . connect ( dsn =... ) # or await Porm . connect ( user =... , password =... , database =... , host =... , port =... ) This will create an underlying asyncpg.Connection which is available for inspection as a property on your instance as Porm.connection . You can also pass keyword arguments directly down into the asyncpg.connect method. Connection pooling For many applications like web servers, it's advisable to use a connection pool . from p3orm import Porm await Porm . connect_pool ( dsn =... ) # or await Porm . connect_pool ( user =... , password =... , database =... , host =... , port =... ) This will create an underlying asyncpg.Pool which is available for inspection as a property on your instance as Porm.pool . You can also pass keyword arguments directly down into the asyncpg.create_pool method. Some of these configuration options that are typically modified include min_size , max_size , and max_inactive_connection_lifetime which can be tuned to affect the performance of your application. Disconnecting await Porm . disconnect () This method will close the existing asyncpg.Connection or asyncpg.Pool and remove it from the instance.","title":"Connecting to the Database"},{"location":"tutorial/connecting/#connecting-to-the-database","text":"p3orm allows you to connect either with a direct connection or with a connection pool. You can only connect with one of these at a time on a single instance. If you attempt to establish a new connection or pool while one already exists, p3orm will raise a p3orm.exceptions.AlreadyConnected exception.","title":"Connecting to the database"},{"location":"tutorial/connecting/#regular-connections","text":"With p3orm you can open a single connection to the database. This is useful for simpler short lived applications like a script. You can open a connection by using the _Porm.connect method. from p3orm import Porm await Porm . connect ( dsn =... ) # or await Porm . connect ( user =... , password =... , database =... , host =... , port =... ) This will create an underlying asyncpg.Connection which is available for inspection as a property on your instance as Porm.connection . You can also pass keyword arguments directly down into the asyncpg.connect method.","title":"Regular connections"},{"location":"tutorial/connecting/#connection-pooling","text":"For many applications like web servers, it's advisable to use a connection pool . from p3orm import Porm await Porm . connect_pool ( dsn =... ) # or await Porm . connect_pool ( user =... , password =... , database =... , host =... , port =... ) This will create an underlying asyncpg.Pool which is available for inspection as a property on your instance as Porm.pool . You can also pass keyword arguments directly down into the asyncpg.create_pool method. Some of these configuration options that are typically modified include min_size , max_size , and max_inactive_connection_lifetime which can be tuned to affect the performance of your application.","title":"Connection pooling"},{"location":"tutorial/connecting/#disconnecting","text":"await Porm . disconnect () This method will close the existing asyncpg.Connection or asyncpg.Pool and remove it from the instance.","title":"Disconnecting"},{"location":"tutorial/defining_models/","text":"","title":"Defining models"},{"location":"tutorial/multiple_databases/","text":"Multiple Databases By default, p3orm provides a singleton to connect to an available database as p3orm.core.Porm . You can create your own instance of a _Porm and connect to a second database, though. from p3orm import _Porm first_database = _Porm () await first_database . connect ( dsn =... ) second_database = _Porm () await second_Database . connect ( user =... , password =... , database =... , host =... , port =... )","title":"Multiple Databases"},{"location":"tutorial/multiple_databases/#multiple-databases","text":"By default, p3orm provides a singleton to connect to an available database as p3orm.core.Porm . You can create your own instance of a _Porm and connect to a second database, though. from p3orm import _Porm first_database = _Porm () await first_database . connect ( dsn =... ) second_database = _Porm () await second_Database . connect ( user =... , password =... , database =... , host =... , port =... )","title":"Multiple Databases"},{"location":"tutorial/relationships/","text":"Relationships p3orm supports two types of relationships ForeignKeyRelationship - Analogous to the table having a foreign key. This will always retrieve a single referenced model. ReverseRelationship - Analagous to a different table having a foreign key referencing the current table. This will always retrieve a list of referenced models. Default behavior By default, relationships are not loaded from the database. Instead, all relationship fields are instantiated with the p3orm.table.UNLOADED object. This object will raise a p3orm.exceptions.UnloadedRelationship exception if you try to access any property on it. If a relationship is fetched but there are no values to be fetched (because the foreign key is null, or there is nothing in the reverse relationship), a foreign key relationship field will become None and a reverse relationship field will become the empty list [] . Defining relationships from __future__ import annotations from p3orm import Table , ForeignKeyRelationship , ReverseRelationship , Column class Parent ( Table ): id = Column ( int , \"id\" , pk = True , autogen = True ) children : list [ Child ] = ReverseRelationship ( self_column = \"id\" , foreign_column = \"parent_id\" ) class Child ( Table ): id = Column ( int , \"id\" , pk = True , autogen = True ) name = Column ( str , \"name\" ) parent_id = Column ( int , \"parent_id\" ) parent : Parent = ForeignKeyRelationship ( self_column = \"parent_id\" , foreign_column = \"id\" ) It's not necessary to import from future import __annotations__ . If you don't import, just know you will have to mark your anotations as strings, e.g. children: list[\"Child\"] or parent: \"Parent\" Fetching relationships Fetching foreign key relationships child = await Child . fetch_one ( Child . id == 1 ) child . parent # <p3orm.table.UNLOADED> [ child ] = await Child . fetch_related ([ child ], [[ Child . parent ]]) child . parent # <Parent> fetch_related accepts a Sequence[Sequence[_Relationship]] to allow for fetching multiple relationships and deeply nested relationships. Fetching reverse foreign key relationships parent = await Parent . fetch_one ( Parent . id == 1 ) parent . children # <p3orm.table.UNLOADED> [ parent ] = await Parent . fetch_related ([ parent ], [[ Parent . children ]]) parent . children # <list[Child]> Fetching multiple relationships thing = await Thing . fetch_one ( Thing . id == 1 ) [ thing ] = await Thing . fetch_related ([ thing ], [[ thing . f1 ], [ thing . f2 ], [ thing . rr1 ]]) thing . f1 # <Model> thing . f2 # <Model2> thing . rr1 # <list[Model3]> Fetching deeply nested relationships thing = await Thing . fetch_one ( Thing . id == 1 ) [ thing ] = await Thing . fetch_related ([ thing ], [[ thing . children , thing . children . child ]]) thing . children # <list[Child]> thing . children [ 0 ] . child # <Child> Prefetching relationships p3orm allows you to prefetch relationships while making other requests, rather than having to relationships explicitly. These are passed in as the prefetch keyword argument that is of the same format as the relationships passed into fetch_related . The methods that support prefetching are: Table.fetch_one Table.fetch_first Table.fetch_all Table.insert_one Table.insert_many Table.update_one Usage company_with_employees = await Company . fetch_one ( Company . id == 1 , prefetch = [[ Company . employees ]])","title":"Relationships"},{"location":"tutorial/relationships/#relationships","text":"p3orm supports two types of relationships ForeignKeyRelationship - Analogous to the table having a foreign key. This will always retrieve a single referenced model. ReverseRelationship - Analagous to a different table having a foreign key referencing the current table. This will always retrieve a list of referenced models.","title":"Relationships"},{"location":"tutorial/relationships/#default-behavior","text":"By default, relationships are not loaded from the database. Instead, all relationship fields are instantiated with the p3orm.table.UNLOADED object. This object will raise a p3orm.exceptions.UnloadedRelationship exception if you try to access any property on it. If a relationship is fetched but there are no values to be fetched (because the foreign key is null, or there is nothing in the reverse relationship), a foreign key relationship field will become None and a reverse relationship field will become the empty list [] .","title":"Default behavior"},{"location":"tutorial/relationships/#defining-relationships","text":"from __future__ import annotations from p3orm import Table , ForeignKeyRelationship , ReverseRelationship , Column class Parent ( Table ): id = Column ( int , \"id\" , pk = True , autogen = True ) children : list [ Child ] = ReverseRelationship ( self_column = \"id\" , foreign_column = \"parent_id\" ) class Child ( Table ): id = Column ( int , \"id\" , pk = True , autogen = True ) name = Column ( str , \"name\" ) parent_id = Column ( int , \"parent_id\" ) parent : Parent = ForeignKeyRelationship ( self_column = \"parent_id\" , foreign_column = \"id\" ) It's not necessary to import from future import __annotations__ . If you don't import, just know you will have to mark your anotations as strings, e.g. children: list[\"Child\"] or parent: \"Parent\"","title":"Defining relationships"},{"location":"tutorial/relationships/#fetching-relationships","text":"","title":"Fetching relationships"},{"location":"tutorial/relationships/#fetching-foreign-key-relationships","text":"child = await Child . fetch_one ( Child . id == 1 ) child . parent # <p3orm.table.UNLOADED> [ child ] = await Child . fetch_related ([ child ], [[ Child . parent ]]) child . parent # <Parent> fetch_related accepts a Sequence[Sequence[_Relationship]] to allow for fetching multiple relationships and deeply nested relationships.","title":"Fetching foreign key relationships"},{"location":"tutorial/relationships/#fetching-reverse-foreign-key-relationships","text":"parent = await Parent . fetch_one ( Parent . id == 1 ) parent . children # <p3orm.table.UNLOADED> [ parent ] = await Parent . fetch_related ([ parent ], [[ Parent . children ]]) parent . children # <list[Child]>","title":"Fetching reverse foreign key relationships"},{"location":"tutorial/relationships/#fetching-multiple-relationships","text":"thing = await Thing . fetch_one ( Thing . id == 1 ) [ thing ] = await Thing . fetch_related ([ thing ], [[ thing . f1 ], [ thing . f2 ], [ thing . rr1 ]]) thing . f1 # <Model> thing . f2 # <Model2> thing . rr1 # <list[Model3]>","title":"Fetching multiple relationships"},{"location":"tutorial/relationships/#fetching-deeply-nested-relationships","text":"thing = await Thing . fetch_one ( Thing . id == 1 ) [ thing ] = await Thing . fetch_related ([ thing ], [[ thing . children , thing . children . child ]]) thing . children # <list[Child]> thing . children [ 0 ] . child # <Child>","title":"Fetching deeply nested relationships"},{"location":"tutorial/relationships/#prefetching-relationships","text":"p3orm allows you to prefetch relationships while making other requests, rather than having to relationships explicitly. These are passed in as the prefetch keyword argument that is of the same format as the relationships passed into fetch_related . The methods that support prefetching are: Table.fetch_one Table.fetch_first Table.fetch_all Table.insert_one Table.insert_many Table.update_one","title":"Prefetching relationships"},{"location":"tutorial/relationships/#usage","text":"company_with_employees = await Company . fetch_one ( Company . id == 1 , prefetch = [[ Company . employees ]])","title":"Usage"}]}