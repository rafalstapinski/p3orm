{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"p3orm Utilitarian Python ORM for Postgres/SQLite powered by asyncpg / aiosqlite , Pydantic , and PyPika Documentation : https://rafalstapinski.github.io/p3orm Source Code : https://github.com/rafalstapinski/p3orm Philosophy 90% of the time we talk to a database is with a CRUD operation. p3orm provides convenience helpers for fetching (one, first, many), inserting (one, many), updating (one), and deleting (one, many). The remaining 10% is a bit more complicated. p3orm doesn't attempt to hide SQL queries or database interactions behind any magic. Instead, it empowers you to write direct and legible SQL queries with PyPika and execute them explicitly against the database. Notably, objects created or fetched by p3orm are dead, they're just Pydantic models. If you want to interact with the database, you do so explicitly. tl;dr - p3orm makes easy things easy, and hard things possible Features Comprehensive type annotations (full intellisense support) String type validation an parsing powered by Pydantic Support for PyPika queries Support for all postgres datatypes Support for all sqlite datatypes Installation Install with poetry poetry add p3orm [ sqlite ] # or poetry add p3orm [ postgres ] or with pip pip install p3orm [ sqlite ] # or pip install p3orm [ postgres ] The [sqlite] extra installs aiosqlite as p3orm's database driver, whereas [postgres] installs asyncpg . Basic Usage from datetime import datetime from p3orm import Column , Table from p3orm import sqlite as db # or: from p3orm import postgres as db class Thing ( Table ): id = Column ( int , pk = True , autogen = True ) name = Column ( str ) created_at = Column ( datetime , autogen = True ) await db () . connect ( \":memory:\" ) thing = Thing ( name = \"Name\" ) inserted = await Thing . insert_one ( thing ) fetched = await Thing . fetch_first ( Thing . id == 1 ) fetched . name = \"Changed\" updated = await Thing . update_one ( fetched ) deleted = await Thing . delete_where ( Thing . id == updated . id ) await db () . disconnect ()","title":"About"},{"location":"#p3orm","text":"Utilitarian Python ORM for Postgres/SQLite powered by asyncpg / aiosqlite , Pydantic , and PyPika Documentation : https://rafalstapinski.github.io/p3orm Source Code : https://github.com/rafalstapinski/p3orm","title":"p3orm"},{"location":"#tldr-p3orm-makes-easy-things-easy-and-hard-things-possible","text":"","title":"tl;dr - p3orm makes easy things easy, and hard things possible"},{"location":"contributing/","text":"Contributing to p3orm p3orm is still in its infancy. If you find a bug, open an issue with a detailed description and steps to reproduce. If you're looking for a feature, open an issue with a detailed description and use case. Feel free open a pull request if you want to contribure directly!","title":"Contributing"},{"location":"contributing/#contributing-to-p3orm","text":"p3orm is still in its infancy. If you find a bug, open an issue with a detailed description and steps to reproduce. If you're looking for a feature, open an issue with a detailed description and use case. Feel free open a pull request if you want to contribure directly!","title":"Contributing to p3orm"},{"location":"getting_started/","text":"Getting started Connecting to a database Postgres from p3orm import postgres db = postgres () await db . connect ( \"postgresql://user:pass@host:port\" ) # or await db . connect ( user =... , password =... , database =... , host =... , port =... ) db . is_connected () # False SQLite from p3orm import sqlite db = sqlite () await db . connect ( \":memory:\" ) Disconnecting Postgres await postgres () . disconnect () postgres () . is_connected () # False SQLite await sqlite () . disconnect () p3orm currently allows you to connect to a single database within a process. You can fetch the Postgres driver with postgres() from p3orm.core and the SQLite driver with sqlite() from p3orm.core . Defining models from datetime import datetime from p3orm import Table , Column class Thing ( Table ): __tablename__ = \"thing\" id = Column ( int , autogen = True ) name = Column ( Optional [ str ]) created_at = Column ( datetime , autogen = True ) Column parameters _type : Specifies the type of the column, will be used to convert between Python and Postgres. This also generates the type annotation for an instance of your model. For a list of supported types, see the asyncpg docs . name : Specifies the name of the column. This (currently) has to match the name of the field on the class as well. pk : Specifies whether this is the primary key. This is used for the update_one convenience function. autogen : Specifies whether Postgres will automatically generate/update the value of this field, e.g. SERIAL for ids or DEFAULT CURRENT_TIMESTAMP for created_at or updated_at type fields. Basic queries p3orm.table.Table provides the following convenience methods for executing queries with basic criteria. Table.fetch_one will raise a MultipleResultsReturned or NoResultsReturned if exactly one result isn't returned. Table.fetch_first will return the first result from a query or None . Table.fetch_all will return a list of results (or an empty list) of a query. Table.insert_one will insert exactly one model. Table.insert_many will insert multiple models with a performant bulk insert query. Table.update_one will accept a single model and update it based on its primary key. Table.delete_where will delete and return all rows that match a criterion. All of the above methods use parameterized queries under the hood to protect against SQL injections. Creating inserted_result = await Thing . insert_one ( Thing ( name = \"thing 1\" )) to_insert = [ Thing ( name = \"thing 2\" ), Thing ( name = \"thing 3\" )] inserted_results = await Thing . insert_many ( to_insert ) Note that we didn't specify the id or created_at fields. Those are autogenerated by Postgres, so we let the database do the work. We also didn't explicitly specify whether the fields are nullable or not. Again, we offload all validation to the database as the source of truth, and only specify the Optional type for local type checking and intellisense. It is best practice to discard locally created models after they've been inserted and replace them with the returned set as they will contain all the database-generated and validated field values. Retrieving everything = await Thing . fetch_all () filtered = await Thing . fetch_all ( Thing . id > 2 ) first = await Thing . fetch_first ( Thing . id > 2 ) one = await Thing . fetch_one ( Thing . id == 1 ) Updating thing = await Thing . fetch_one ( Thing . id == 2 ) thing . name = \"Changed\" updated_thing = await Thing . update_one ( thing ) It is best practice to discard the local model after an update and replace it with the updated result as it will contain any database-updated fields. Deleting deleted_things = await Thing . delete_where ( Thing . id > 10 ) Table.delete_where always returns a list of the deleted records.","title":"Getting Started"},{"location":"getting_started/#getting-started","text":"","title":"Getting started"},{"location":"getting_started/#connecting-to-a-database","text":"","title":"Connecting to a database"},{"location":"getting_started/#postgres","text":"from p3orm import postgres db = postgres () await db . connect ( \"postgresql://user:pass@host:port\" ) # or await db . connect ( user =... , password =... , database =... , host =... , port =... ) db . is_connected () # False","title":"Postgres"},{"location":"getting_started/#sqlite","text":"from p3orm import sqlite db = sqlite () await db . connect ( \":memory:\" )","title":"SQLite"},{"location":"getting_started/#disconnecting","text":"","title":"Disconnecting"},{"location":"getting_started/#postgres_1","text":"await postgres () . disconnect () postgres () . is_connected () # False","title":"Postgres"},{"location":"getting_started/#sqlite_1","text":"await sqlite () . disconnect () p3orm currently allows you to connect to a single database within a process. You can fetch the Postgres driver with postgres() from p3orm.core and the SQLite driver with sqlite() from p3orm.core .","title":"SQLite"},{"location":"getting_started/#defining-models","text":"from datetime import datetime from p3orm import Table , Column class Thing ( Table ): __tablename__ = \"thing\" id = Column ( int , autogen = True ) name = Column ( Optional [ str ]) created_at = Column ( datetime , autogen = True )","title":"Defining models"},{"location":"getting_started/#column-parameters","text":"_type : Specifies the type of the column, will be used to convert between Python and Postgres. This also generates the type annotation for an instance of your model. For a list of supported types, see the asyncpg docs . name : Specifies the name of the column. This (currently) has to match the name of the field on the class as well. pk : Specifies whether this is the primary key. This is used for the update_one convenience function. autogen : Specifies whether Postgres will automatically generate/update the value of this field, e.g. SERIAL for ids or DEFAULT CURRENT_TIMESTAMP for created_at or updated_at type fields.","title":"Column parameters"},{"location":"getting_started/#basic-queries","text":"p3orm.table.Table provides the following convenience methods for executing queries with basic criteria. Table.fetch_one will raise a MultipleResultsReturned or NoResultsReturned if exactly one result isn't returned. Table.fetch_first will return the first result from a query or None . Table.fetch_all will return a list of results (or an empty list) of a query. Table.insert_one will insert exactly one model. Table.insert_many will insert multiple models with a performant bulk insert query. Table.update_one will accept a single model and update it based on its primary key. Table.delete_where will delete and return all rows that match a criterion. All of the above methods use parameterized queries under the hood to protect against SQL injections.","title":"Basic queries"},{"location":"getting_started/#creating","text":"inserted_result = await Thing . insert_one ( Thing ( name = \"thing 1\" )) to_insert = [ Thing ( name = \"thing 2\" ), Thing ( name = \"thing 3\" )] inserted_results = await Thing . insert_many ( to_insert ) Note that we didn't specify the id or created_at fields. Those are autogenerated by Postgres, so we let the database do the work. We also didn't explicitly specify whether the fields are nullable or not. Again, we offload all validation to the database as the source of truth, and only specify the Optional type for local type checking and intellisense. It is best practice to discard locally created models after they've been inserted and replace them with the returned set as they will contain all the database-generated and validated field values.","title":"Creating"},{"location":"getting_started/#retrieving","text":"everything = await Thing . fetch_all () filtered = await Thing . fetch_all ( Thing . id > 2 ) first = await Thing . fetch_first ( Thing . id > 2 ) one = await Thing . fetch_one ( Thing . id == 1 )","title":"Retrieving"},{"location":"getting_started/#updating","text":"thing = await Thing . fetch_one ( Thing . id == 2 ) thing . name = \"Changed\" updated_thing = await Thing . update_one ( thing ) It is best practice to discard the local model after an update and replace it with the updated result as it will contain any database-updated fields.","title":"Updating"},{"location":"getting_started/#deleting","text":"deleted_things = await Thing . delete_where ( Thing . id > 10 ) Table.delete_where always returns a list of the deleted records.","title":"Deleting"},{"location":"tutorial/complex_queries/","text":"Complex queries p3orm has full support for executing PyPika queries. PyPika queries are constructed by building blocks that are analogous to the underlying SQL, the learning curve is minimal if you already know SQL. Available PyPika shortcuts select - Equivalent to PyPika's QueryBuilder().from_(tablename).select(field) . This defaults to return everything ( * ) but you can pass in a specific model field for executing subqueries. update - Equivalent to PyPika's QueryBuilder().update(tablename) . You can then chain this with your own .where() and .set() statements. delete - Equivalent to PyPika's QueryBuilder().delete().from(tablename) . You can then chain this with your own .where() statement. from_ -> Calls underlying QueryBuilder().from_(tablename) , useful if you need to execute broader queries. These shortcuts only build queries. To run the query against a database you must use your driver's .fetch_many or .fetch_many methods. Selecting with PyPika queries subquery = OtherThing . select ( OtherThing . thing_id ) . where ( OtherThing . id == 1 ) query = Thing . select () . where ( Thing . id . isin ( subquery )) things = await postgres () . fetch_many ( Thing , query ) Updating with PyPika queries p3orm provides the with_returning function to wrap PyPika insert/udpate/delete queries so that they return results. from p3orm import with_returning query = Thing . update () . where ( Thing . name == \"name\" ) . set ( Thing . name , \"another name\" ) updated_things = await postgres () . fetch_many ( with_returning ( query )) Deleting with PyPika queries from p3orm.utils import with_returning subquery = OtherThing . from_ () . select ( \"thing_id\" ) . where ( OtherThing . id == 1 ) query = Thing . delete () . where ( Thing . id . isin ( subquery )) deleted_things = await postgres () . fetch_many ( with_returning ( query ))","title":"Complex Queries"},{"location":"tutorial/complex_queries/#complex-queries","text":"p3orm has full support for executing PyPika queries. PyPika queries are constructed by building blocks that are analogous to the underlying SQL, the learning curve is minimal if you already know SQL.","title":"Complex queries"},{"location":"tutorial/complex_queries/#available-pypika-shortcuts","text":"select - Equivalent to PyPika's QueryBuilder().from_(tablename).select(field) . This defaults to return everything ( * ) but you can pass in a specific model field for executing subqueries. update - Equivalent to PyPika's QueryBuilder().update(tablename) . You can then chain this with your own .where() and .set() statements. delete - Equivalent to PyPika's QueryBuilder().delete().from(tablename) . You can then chain this with your own .where() statement. from_ -> Calls underlying QueryBuilder().from_(tablename) , useful if you need to execute broader queries. These shortcuts only build queries. To run the query against a database you must use your driver's .fetch_many or .fetch_many methods.","title":"Available PyPika shortcuts"},{"location":"tutorial/complex_queries/#selecting-with-pypika-queries","text":"subquery = OtherThing . select ( OtherThing . thing_id ) . where ( OtherThing . id == 1 ) query = Thing . select () . where ( Thing . id . isin ( subquery )) things = await postgres () . fetch_many ( Thing , query )","title":"Selecting with PyPika queries"},{"location":"tutorial/complex_queries/#updating-with-pypika-queries","text":"p3orm provides the with_returning function to wrap PyPika insert/udpate/delete queries so that they return results. from p3orm import with_returning query = Thing . update () . where ( Thing . name == \"name\" ) . set ( Thing . name , \"another name\" ) updated_things = await postgres () . fetch_many ( with_returning ( query ))","title":"Updating with PyPika queries"},{"location":"tutorial/complex_queries/#deleting-with-pypika-queries","text":"from p3orm.utils import with_returning subquery = OtherThing . from_ () . select ( \"thing_id\" ) . where ( OtherThing . id == 1 ) query = Thing . delete () . where ( Thing . id . isin ( subquery )) deleted_things = await postgres () . fetch_many ( with_returning ( query ))","title":"Deleting with PyPika queries"},{"location":"tutorial/connecting/","text":"Connecting to a Postgres database p3orm allows you to connect either with a direct connection or with a connection pool. You can only connect with one of these at a time on a single instance. If you attempt to establish a new connection or pool while one already exists, p3orm will raise a p3orm.exceptions.AlreadyConnected exception. Regular connections With p3orm you can open a single connection to the database. This is useful for simpler short lived applications like a script. You can open a connection by using the PostgresDriver.connect method. from p3orm import postgres await postgres () . connect ( dsn =... ) # or await postgres () . connect ( user =... , password =... , database =... , host =... , port =... ) This will create an underlying asyncpg.Connection which is available for inspection as a property on your instance as postgres().connection . You can also pass keyword arguments directly down into the asyncpg.connect method. Connection pooling For many applications like web servers, it's advisable to use a connection pool . from p3orm import postgres await postgres () . connect_pool ( dsn =... ) # or await postgres () . connect_pool ( user =... , password =... , database =... , host =... , port =... ) This will create an underlying asyncpg.Pool which is available for inspection as a property on your instance as postgres().pool . You can also pass keyword arguments directly down into the asyncpg.create_pool method. Some of these configuration options that are typically modified include min_size , max_size , and max_inactive_connection_lifetime which can be tuned to affect the performance of your application. Disconnecting await postgres () . disconnect () This method will close the existing asyncpg.Connection or asyncpg.Pool and remove it from the instance.","title":"Connecting to a Postgres Database"},{"location":"tutorial/connecting/#connecting-to-a-postgres-database","text":"p3orm allows you to connect either with a direct connection or with a connection pool. You can only connect with one of these at a time on a single instance. If you attempt to establish a new connection or pool while one already exists, p3orm will raise a p3orm.exceptions.AlreadyConnected exception.","title":"Connecting to a Postgres database"},{"location":"tutorial/connecting/#regular-connections","text":"With p3orm you can open a single connection to the database. This is useful for simpler short lived applications like a script. You can open a connection by using the PostgresDriver.connect method. from p3orm import postgres await postgres () . connect ( dsn =... ) # or await postgres () . connect ( user =... , password =... , database =... , host =... , port =... ) This will create an underlying asyncpg.Connection which is available for inspection as a property on your instance as postgres().connection . You can also pass keyword arguments directly down into the asyncpg.connect method.","title":"Regular connections"},{"location":"tutorial/connecting/#connection-pooling","text":"For many applications like web servers, it's advisable to use a connection pool . from p3orm import postgres await postgres () . connect_pool ( dsn =... ) # or await postgres () . connect_pool ( user =... , password =... , database =... , host =... , port =... ) This will create an underlying asyncpg.Pool which is available for inspection as a property on your instance as postgres().pool . You can also pass keyword arguments directly down into the asyncpg.create_pool method. Some of these configuration options that are typically modified include min_size , max_size , and max_inactive_connection_lifetime which can be tuned to affect the performance of your application.","title":"Connection pooling"},{"location":"tutorial/connecting/#disconnecting","text":"await postgres () . disconnect () This method will close the existing asyncpg.Connection or asyncpg.Pool and remove it from the instance.","title":"Disconnecting"},{"location":"tutorial/defining_models/","text":"Defining models Defining a table Models are used in p3orm to reflect the tables in your database. They can be created by defining a class the inherits from p3orm.table.Table . from p3orm import Table class MyTable ( Table ): __tablename__ = \"my_table\" All p3orm models require a __tablename__ property which must match name of the table in your database. Defining columns Your models define tables using the Column function. from datetime import datetime from typing import Optional from p3orm import Table , Column class MyTable ( Column ): __tablename__ = \"my_table\" id = Column ( int , pk = True , autogen = True ) name = Column ( Optional [ str ]) property_name = Column ( str , \"column_name\" ) created_at = Column ( datetime , autogen = True ) Each column has can be defined with the following parameters _type - This is a positional argument. It is the first and only required argument you must pass to define your column. It is what p3orm will use to serialize and deserialize the value between Python and the database. column_name - This is the name of the column in the database. If not specified, p3orm will use the name of the field as the column name. pk - This is a boolean flag which tells p3orm that this column is the primary key of your table. autogen - This is a boolean flag which tells p3orm that this column has a DEFAULT constant or expression value in the database. Column types p3orm uses Pydantic under the hood to map query results into Python objects. All standard data types are supported out of the box, including numbers, text, arrays, composite types, range types, enumerations and any combination of them. p3orm also uses these types for intellisense within your IDE, so your models' field types will be automatically inferred by your editor! For a list of supported types, see the asyncpg docs . Optional types and nullable columns If a column is nullable/optional in the database, its type should be Optional[ ] (or | None ). When a field is required/not-nullable: p3orm will raise a pydantic.error_wrappers.ValidationError if you try to create an instance of the object locally without providing a non-null value. p3orm will raise an asyncpg.exceptions.NotNullViolationError if you fetch an object from the database which has a null value. A model's fields' optionality should match the nullability of the column in the database. Default columns Column marked with autogen=True are columns whose values are generated at the database layer. Marking a field with autogen=True tells p3orm to ignore user-defined values in the Table 's insert and update statements. Locally changing the value of one of these fields on a model will not raise an error, but persisting that change to the database will have no effect. This feature is used for columns like created_at , updated_at , or auto incrementing IDs.","title":"Defining Models"},{"location":"tutorial/defining_models/#defining-models","text":"","title":"Defining models"},{"location":"tutorial/defining_models/#defining-a-table","text":"Models are used in p3orm to reflect the tables in your database. They can be created by defining a class the inherits from p3orm.table.Table . from p3orm import Table class MyTable ( Table ): __tablename__ = \"my_table\" All p3orm models require a __tablename__ property which must match name of the table in your database.","title":"Defining a table"},{"location":"tutorial/defining_models/#defining-columns","text":"Your models define tables using the Column function. from datetime import datetime from typing import Optional from p3orm import Table , Column class MyTable ( Column ): __tablename__ = \"my_table\" id = Column ( int , pk = True , autogen = True ) name = Column ( Optional [ str ]) property_name = Column ( str , \"column_name\" ) created_at = Column ( datetime , autogen = True ) Each column has can be defined with the following parameters _type - This is a positional argument. It is the first and only required argument you must pass to define your column. It is what p3orm will use to serialize and deserialize the value between Python and the database. column_name - This is the name of the column in the database. If not specified, p3orm will use the name of the field as the column name. pk - This is a boolean flag which tells p3orm that this column is the primary key of your table. autogen - This is a boolean flag which tells p3orm that this column has a DEFAULT constant or expression value in the database.","title":"Defining columns"},{"location":"tutorial/defining_models/#column-types","text":"p3orm uses Pydantic under the hood to map query results into Python objects. All standard data types are supported out of the box, including numbers, text, arrays, composite types, range types, enumerations and any combination of them. p3orm also uses these types for intellisense within your IDE, so your models' field types will be automatically inferred by your editor! For a list of supported types, see the asyncpg docs .","title":"Column types"},{"location":"tutorial/defining_models/#optional-types-and-nullable-columns","text":"If a column is nullable/optional in the database, its type should be Optional[ ] (or | None ). When a field is required/not-nullable: p3orm will raise a pydantic.error_wrappers.ValidationError if you try to create an instance of the object locally without providing a non-null value. p3orm will raise an asyncpg.exceptions.NotNullViolationError if you fetch an object from the database which has a null value. A model's fields' optionality should match the nullability of the column in the database.","title":"Optional types and nullable columns"},{"location":"tutorial/defining_models/#default-columns","text":"Column marked with autogen=True are columns whose values are generated at the database layer. Marking a field with autogen=True tells p3orm to ignore user-defined values in the Table 's insert and update statements. Locally changing the value of one of these fields on a model will not raise an error, but persisting that change to the database will have no effect. This feature is used for columns like created_at , updated_at , or auto incrementing IDs.","title":"Default columns"},{"location":"tutorial/relationships/","text":"Relationships p3orm supports two types of relationships ForeignKeyRelationship - Analogous to the table having a foreign key. This will always retrieve a single referenced model. ReverseRelationship - Analagous to a different table having a foreign key referencing the current table. This will always retrieve a list of referenced models. Default behavior By default, relationships are not loaded from the database. Instead, all relationship fields are instantiated with the p3orm.table.UNLOADED object. This object will raise a p3orm.exceptions.UnloadedRelationship exception if you try to access any property on it. If a relationship is fetched but there are no values to be fetched (because the foreign key is null, or there is nothing in the reverse relationship), a foreign key relationship field will become None and a reverse relationship field will become the empty list [] . Defining relationships from __future__ import annotations from p3orm import Table , ForeignKeyRelationship , ReverseRelationship , Column class Parent ( Table ): id = Column ( int , pk = True , autogen = True ) children : list [ Child ] = ReverseRelationship ( self_column = \"id\" , foreign_column = \"parent_id\" ) class Child ( Table ): id = Column ( int , pk = True , autogen = True ) name = Column ( str ) parent_id = Column ( int ) parent : Parent = ForeignKeyRelationship ( self_column = \"parent_id\" , foreign_column = \"id\" ) It's not necessary to import from future import __annotations__ . If you don't import, just know you will have to mark your anotations as strings, e.g. children: list[\"Child\"] or parent: \"Parent\" Fetching relationships Fetching foreign key relationships child = await Child . fetch_one ( Child . id == 1 ) child . parent # <p3orm.table.UNLOADED> [ child ] = await Child . fetch_related ([ child ], [[ Child . parent ]]) child . parent # <Parent> fetch_related accepts a Sequence[Sequence[_Relationship]] to allow for fetching multiple relationships and deeply nested relationships. Fetching reverse foreign key relationships parent = await Parent . fetch_one ( Parent . id == 1 ) parent . children # <p3orm.table.UNLOADED> [ parent ] = await Parent . fetch_related ([ parent ], [[ Parent . children ]]) parent . children # <list[Child]> Fetching multiple relationships thing = await Thing . fetch_one ( Thing . id == 1 ) [ thing ] = await Thing . fetch_related ([ thing ], [[ thing . f1 ], [ thing . f2 ], [ thing . rr1 ]]) thing . f1 # <Model> thing . f2 # <Model2> thing . rr1 # <list[Model3]> Fetching deeply nested relationships thing = await Thing . fetch_one ( Thing . id == 1 ) [ thing ] = await Thing . fetch_related ([ thing ], [[ thing . children , thing . children . child ]]) thing . children # <list[Child]> thing . children [ 0 ] . child # <Child> Prefetching relationships p3orm allows you to prefetch relationships while making other requests, rather than having to relationships explicitly. These are passed in as the prefetch keyword argument that is of the same format as the relationships passed into fetch_related . The methods that support prefetching are: Table.fetch_one Table.fetch_first Table.fetch_all Table.insert_one Table.insert_many Table.update_one Usage company_with_employees = await Company . fetch_one ( Company . id == 1 , prefetch = [[ Company . employees ]])","title":"Relationships"},{"location":"tutorial/relationships/#relationships","text":"p3orm supports two types of relationships ForeignKeyRelationship - Analogous to the table having a foreign key. This will always retrieve a single referenced model. ReverseRelationship - Analagous to a different table having a foreign key referencing the current table. This will always retrieve a list of referenced models.","title":"Relationships"},{"location":"tutorial/relationships/#default-behavior","text":"By default, relationships are not loaded from the database. Instead, all relationship fields are instantiated with the p3orm.table.UNLOADED object. This object will raise a p3orm.exceptions.UnloadedRelationship exception if you try to access any property on it. If a relationship is fetched but there are no values to be fetched (because the foreign key is null, or there is nothing in the reverse relationship), a foreign key relationship field will become None and a reverse relationship field will become the empty list [] .","title":"Default behavior"},{"location":"tutorial/relationships/#defining-relationships","text":"from __future__ import annotations from p3orm import Table , ForeignKeyRelationship , ReverseRelationship , Column class Parent ( Table ): id = Column ( int , pk = True , autogen = True ) children : list [ Child ] = ReverseRelationship ( self_column = \"id\" , foreign_column = \"parent_id\" ) class Child ( Table ): id = Column ( int , pk = True , autogen = True ) name = Column ( str ) parent_id = Column ( int ) parent : Parent = ForeignKeyRelationship ( self_column = \"parent_id\" , foreign_column = \"id\" ) It's not necessary to import from future import __annotations__ . If you don't import, just know you will have to mark your anotations as strings, e.g. children: list[\"Child\"] or parent: \"Parent\"","title":"Defining relationships"},{"location":"tutorial/relationships/#fetching-relationships","text":"","title":"Fetching relationships"},{"location":"tutorial/relationships/#fetching-foreign-key-relationships","text":"child = await Child . fetch_one ( Child . id == 1 ) child . parent # <p3orm.table.UNLOADED> [ child ] = await Child . fetch_related ([ child ], [[ Child . parent ]]) child . parent # <Parent> fetch_related accepts a Sequence[Sequence[_Relationship]] to allow for fetching multiple relationships and deeply nested relationships.","title":"Fetching foreign key relationships"},{"location":"tutorial/relationships/#fetching-reverse-foreign-key-relationships","text":"parent = await Parent . fetch_one ( Parent . id == 1 ) parent . children # <p3orm.table.UNLOADED> [ parent ] = await Parent . fetch_related ([ parent ], [[ Parent . children ]]) parent . children # <list[Child]>","title":"Fetching reverse foreign key relationships"},{"location":"tutorial/relationships/#fetching-multiple-relationships","text":"thing = await Thing . fetch_one ( Thing . id == 1 ) [ thing ] = await Thing . fetch_related ([ thing ], [[ thing . f1 ], [ thing . f2 ], [ thing . rr1 ]]) thing . f1 # <Model> thing . f2 # <Model2> thing . rr1 # <list[Model3]>","title":"Fetching multiple relationships"},{"location":"tutorial/relationships/#fetching-deeply-nested-relationships","text":"thing = await Thing . fetch_one ( Thing . id == 1 ) [ thing ] = await Thing . fetch_related ([ thing ], [[ thing . children , thing . children . child ]]) thing . children # <list[Child]> thing . children [ 0 ] . child # <Child>","title":"Fetching deeply nested relationships"},{"location":"tutorial/relationships/#prefetching-relationships","text":"p3orm allows you to prefetch relationships while making other requests, rather than having to relationships explicitly. These are passed in as the prefetch keyword argument that is of the same format as the relationships passed into fetch_related . The methods that support prefetching are: Table.fetch_one Table.fetch_first Table.fetch_all Table.insert_one Table.insert_many Table.update_one","title":"Prefetching relationships"},{"location":"tutorial/relationships/#usage","text":"company_with_employees = await Company . fetch_one ( Company . id == 1 , prefetch = [[ Company . employees ]])","title":"Usage"}]}