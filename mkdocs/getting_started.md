# Getting started

## Connecting to the database

```python
from p3orm.core import Porm

await Porm.connect("postgresql://user:pass@host:port")

# or

await Porm.connect(user=..., password=..., database=..., host=..., port=...)

Porm.connection.is_closed() # False
```

## Disconnecting
```python
await Porm.disconnect()

Porm.connection.is_closed() # True
```

Porm maintains a singleton to be loaded from `p3orm.core`.

## Defining models
```python
from datetime import datetime
from typing import Optional

from p3orm.table import Table, Column

class Thing(Table):
  __tablename__ = "thing"

  id = Column(int, "id", autogen=True)
  name = Column(Optional[str], "name")
  created_at = Column(datetime, "created_at", autogen=True)
```

### PormField parameters
- `_type`: Specifies the type of the column, will be used to convert between Python and Postgres. This also generates the type annotation for an instance of your model. For a list of supported types, see the [asyncpg docs](https://magicstack.github.io/asyncpg/current/usage.html#type-conversion).
- `name`: Specifies the name of the column. This (currently) has to match the name of the fieldÂ on the class as well.
- `pk`: Specifies whether this is the primary key. This is used for the `update_one` convenience function.
- `autogen`: Specifies whether Postgres will automatically generate/update the value of this field, e.g. `SERIAL` for ids or `DEFAULT CURRENT_TIMESTAMP` for `created_at` or `updated_at` type fields.


## Creating
```python
inserted_result = await Thing.insert_one(Thing(name="thing 1"))

to_insert = [Thing(name="thing 2"), Thing(name="thing 3")]

inserted_results = await Thing.insert_many(to_insert)
```

Notice we didn't specify the `id` or `created_at` fields. Those are autogenerated by Postgres, so we let the database do the work. We also didn't explicitly specify whether the fields are nullable or not. Again, we offload all validation to the database as the source of truth, and only specify the `Optional` type for local type checking and intellisense.


## Retrieving
```python
everything = await Thing.fetch_all()

filtered = await Thing.fetch_all(Thing.id > 2)

first = await Thing.fetch_first(Thing.id > 2)

one = await Thing.fetch_one(Thing.id == 1)
```


## Updating
```python

thing = await Thing.fetch_one(Thing.id == 2)

thing.name = "Changed"

thing = await Thing.update_one(thing)
```


## Deleting
```python
deleted_things = await Thing.delete(Thing.id > 10)
```
`Table.delete` always returns a list of the deleted records.
